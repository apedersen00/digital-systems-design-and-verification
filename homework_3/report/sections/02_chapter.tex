\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Question 1}

Design an FSM that can detect an \lstinline{input_sequence} of 5 consecutive ones. Assume that a new input comes at every clock cycle. The output \lstinline{detected} should be asserted at the same cycle when the 5th '1' is given to the input. It should remain asserted as long as the input remains '1'.

\begin{enumerate}
    \item What should be the type of FSM machine?
    \item Draw the state diagram for the FSM machine.
    \item Derive the next state logic using D flops.
    \item Model the logic that you derived in the previous part in SystemVerilog strucutally.
    \item Model the FSM in a behavioral manner with SystemVerilog.
    \item Verify both structural and behavioral models and compare their results and waveforms together in your report.
\end{enumerate}

\subsection*{Solution}

To implement the FSM we choose a Moore Machine. The output only depends on \textit{if we have seen at least five consecutive 1's}. With a Moore Machine we can simply define five states and assert the output as 1 in the last and sixth state. There is no reason to make the output depend directly on the input, and the Moore Machine gives a glitch-free, synchronized output in comparison to a Mealy Machine. The FSM is defined with states $S_0 \ldots S_5$ and shown in the diagram in \cref{fig:q1}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{assets/q1_fsm.png}
    \caption{State transition diagram for sequence detector in Question 1.}
    \label{fig:q1}
\end{figure}

\begin{table}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|c|c c|c|}
            \hline
            \textbf{State} & 0 & 1 & $w$ \\
            \hline
            $S_0$ & $S_0$ & $S_1$ & 0 \\
            $S_1$ & $S_0$ & $S_2$ & 0 \\
            $S_2$ & $S_0$ & $S_3$ & 0 \\
            $S_3$ & $S_0$ & $S_4$ & 0 \\
            $S_4$ & $S_0$ & $S_5$ & 0 \\
            $S_5$ & $S_0$ & $S_5$ & 1 \\
            \hline
            & \multicolumn{2}{|c|}{Next State} & \\
            \hline
        \end{tabular}
    \end{minipage}%
    \hspace{0.01\textwidth}
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|c|c c|c|}
            \hline
            $Q_2 Q_1 Q_0$ & 0 & 1 & $w$ \\
            \hline
            000 & 000 & 001 & 0 \\
            001 & 000 & 010 & 0 \\
            010 & 000 & 011 & 0 \\
            011 & 000 & 100 & 0 \\
            100 & 000 & 101 & 0 \\
            101 & 000 & 101 & 1 \\
            \hline
            & \multicolumn{2}{|c|}{$D_2 D_1 D_0$} & \\
            \hline
        \end{tabular}
    \end{minipage}
    \caption{State table (left) and transition table (right) for the sequence detector.}
    \label{tab:q1}
\end{table}

\newpage

Denoting each states bits $Q_0, Q_1, Q_2$, and their next state bits for $D_0, D_1, D_2$, the transition table is shown in \cref{tab:q1}. Denoting the input, $j$, Karnaugh maps for deducing logic expressions are shown below.

\begin{center}
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{karnaugh-map}[4][4][1][$j$][$Q_0$][$Q_1$][$Q_2$]
            \maxterms{0, 1, 2, 3, 4, 5, 6, 8, 10}
            \minterms{7, 9, 11}
            \indeterminants{12, 13, 14, 15}
            \implicant{13}{11}
            \implicant{7}{15}
        \end{karnaugh-map}

        \vspace{-40pt}
        \[
        D_2 = Q_1 Q_0 j + Q_2 j
        \]
    \end{minipage}%
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{karnaugh-map}[4][4][1][$j$][$Q_0$][$Q_1$][$Q_2$]
            \maxterms{0, 1, 2, 4, 6, 7, 8, 9, 10, 11}
            \minterms{3, 5}
            \indeterminants{12, 13, 14, 15}
            \implicant{5}{13}
            \implicant{3}{3}
        \end{karnaugh-map}

        \vspace{-40pt}
        \[
        D_1 = Q_1 \overline{Q_0} j + \overline{Q_2} \, \overline{Q_1} Q_0 j
        \]
    \end{minipage}
\end{center}

\begin{center}
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{karnaugh-map}[4][4][1][$j$][$Q_0$][$Q_1$][$Q_2$]
            \maxterms{0, 2, 3, 4, 6, 7, 8, 10}
            \minterms{1, 5, 9, 11}
            \indeterminants{12, 13, 14, 15}
            \implicant{1}{9}
            \implicant{13}{11}
        \end{karnaugh-map}

        \vspace{-40pt}
        \[
        D_0 = \overline{Q_0} j + Q_2 j
        \]
    \end{minipage}%
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{karnaugh-map}[4][2][1][$Q_0$][$Q_1$][$Q_2$]
            \maxterms{0, 1, 2, 3, 4}
            \minterms{5}
            \indeterminants{6, 7}
            \implicant{5}{7}
        \end{karnaugh-map}

        \vspace{-40pt}
        \[
        w = Q_2 Q_0
        \]
    \end{minipage}
\end{center}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{assets/q1_wave.pdf}
    \caption{Waveforms for the structural and behavioral implementation.}
    \label{fig:q1_wave}
\end{figure}

\newpage

Using the found expressions for the next flip flop states, $D_0 \ldots D_2$, we can implement them directory in SystemVerilog to get the expected functionality. On a higher abstraction level, a behavioral implementation can be made, splitting the logic into a sequential \lstinline{always} block and a combination \lstinline{always} block. Both modules were verified simultaneously with the results shown in \cref{fig:q1_wave}. Implementations of both are shown in the following pages but can otherwise be found in:

\begin{itemize}
    \item \lstinline{hdl/q1/src/seq_detector_struct.sv}
    \item \lstinline{hdl/q1/src/seq_detector_behav.sv}
\end{itemize}

\begin{svminted}{Sequence Detector - Structural Implementation}
module seq_detector_struct (
    input   logic clk_i,
    input   logic rstn_i,
    input   logic seq_i,
    output  logic det_o
  );

  logic [2:0] Q;
  logic [2:0] D;

  assign D[2] = (Q[1] & Q[0] & seq_i) | (Q[2] & seq_i);
  assign D[1] = (Q[1] & ~Q[0] & seq_i) | (~Q[2] & ~Q[1] & Q[0] & seq_i);
  assign D[0] = (~Q[0] & seq_i) | Q[2] & seq_i;

  assign det_o = Q[2] & Q[0];

  always_ff @(posedge clk_i or negedge rstn_i) begin
    if (!rstn_i) begin
      Q <= 3'b000;
    end
    else begin
      Q <= D;
    end
  end

endmodule
\end{svminted}

\newpage

\begin{svminted}{Sequence Detector - Behavioral Implementation}
module seq_detector_behav (
    input   logic clk_i,
    input   logic rstn_i,
    input   logic seq_i,
    output  logic det_o
  );

  typedef enum logic [2:0] {
    S0,
    S1,
    S2,
    S3,
    S4,
    S5
  } state_t;

  state_t cur_state, nxt_state;

  always_ff @(posedge clk_i or negedge rstn_i) begin
    if (!rstn_i) begin
      cur_state <= S0;
    end
    else begin
      cur_state <= nxt_state;
    end
  end

  always_comb begin
    nxt_state = S0;

    case (cur_state)
      S0: nxt_state = seq_i ? S1 : S0;
      S1: nxt_state = seq_i ? S2 : S0;
      S2: nxt_state = seq_i ? S3 : S0;
      S3: nxt_state = seq_i ? S4 : S0;
      S4: nxt_state = seq_i ? S5 : S0;
      S5: nxt_state = seq_i ? S5 : S0;
      default: nxt_state = S0;
    endcase
  end

  assign det_o = (cur_state == S5) ? 1'b1 : 1'b0;

endmodule
\end{svminted}

\newpage

\section{Question 2}

Design a message conversion system with the conversion rule below:

For every cycle, if the input message bit is '0', toggle the current output bit; if the input message bit is '1', keep the output bit unchanged.

For example, let the input message be $x$, and the output message be $z$. Assuming $z$ initially is '1'. Given the sequence of $x = 10001110011010$, the output sequence of $z$ should be: 10100001000110. See the figure below.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{assets/q2.png}
\end{figure}

\begin{enumerate}
    \item Draw the state diagram of a \textbf{Mealy FSM} with the same behavior as described above.
    \item Draw the state diagram of a \textbf{Moore FSM} with the same behavior as described above.
    \item Model both FSMs in a behavioral manner using SystemVerilog.
    \item Write a testbench for both FSMs and compare the timing, number of states, and the output waveforms of Mealy and Moore FSMs in your report.
\end{enumerate}

\subsection*{Solution}

For a Moore Machine the output depends \textit{only} upon the current state. For a Mealy Machine the output depends on \textit{both} the current input and state. The state diagrams of the message conversion system implemented using both FSMs are shown in \cref{fig:q2_fsm}.

\vspace{-10pt}
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{assets/q2_mealy.png}
        \caption{Mealy FSM state diagram}
        \label{fig:q2_mealy}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{assets/q2_moore.png}
        \caption{Moore FSM state diagram}
        \label{fig:q2_moore}
    \end{subfigure}
    \caption{State diagrams for the message conversion system using Mealy and Moore FSMs.}
    \label{fig:q2_fsm}
\end{figure}

\newpage



\end{document}
